#summary Examples using Numerical Recipe routines from GroovyLab.

= Introduction =

*`Numerical Recipes`* `is a classic text on Numerical Computation containing a lot of superb quality routines covering wide fields of numerical computing. Perhaps even more important,is that the book explains very well the algorithms on which the routines are based. Therefore, Numerical Recipes (NR) is excellent for students and researchers. Furthermore, generally NR routines are efficient, therefore they also fit for "production" applications. `

`Thanks to Huang Wen Hui that performed a translation to Java, and to the authors of the Numerical Recipes book we can utilize that routines as a standard GroovyLab library and explore them in a Matlab-like way from GroovyLab. This page aims to provide some examples in order to practice the NR routines. We provide the page numbers of the Numerical Recipes book, Edition 3, where the routines are described.` 


== Laplace Interpolation (NR3, p. 150) ==

{{{

import static com.nr.NRUtil.*
import static com.nr.test.NRTestUtil.*
import static java.lang.Math.*

import com.nr.interp.Laplace_interp
import com.nr.ran.Ran


    N=100;     M=100;  NBAD=1000
    sbeps=0.01
    actual = new double[N][M]
    globalflag=false
    
    // Test Laplace_interp
    println("Laplace_interp")
    myran = new Ran(17)
    
    for (int i=0;i<N;i++)
      for (int j=0;j<M;j++)
        actual[i][j]=cos((double)(i)/20.0)*cos((double)(j)/20.0)
        
    mat = buildMatrix(actual)
    for (int i = 0; i < NBAD; i++)  {  // insert "missing" data
      p=myran.int32p()%N
      q=myran.int32p()%M
      mat[p][q]=1.0e99
    }
    printf("     Initial discrepancy: %g\n", maxel(matsub(actual,mat)))
    
    mylaplace = new Laplace_interp(mat)
    mylaplace.solve()
    
    printf("     Final discrepancy: %g\n", maxel(matsub(actual,mat)))
    localflag = maxel(matsub(actual,mat)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** Laplace_interp: Inaccurate Laplace interpolation of missing matrix data.")
    }

    if (globalflag)   println("Failed\n")
    else  println("Passed\n")



}}}


== RBF Interpolation NR3 p. 139 ==
{{{

import static com.nr.test.NRTestUtil.maxel
import static com.nr.test.NRTestUtil.vecsub
import static java.lang.Math.cos

import com.nr.interp.RBF_gauss
import com.nr.interp.RBF_interp
import com.nr.interp.RBF_inversemultiquadric
import com.nr.interp.RBF_multiquadric
import com.nr.interp.RBF_thinplate
import com.nr.ran.Ran


    NPTS=100; NDIM=2; N=10; M=10;
    sbeps=0.05
    pts =new double[NPTS][NDIM]
    y = new double[NPTS]
    
    actual = new double[M]
    
    estim = new double[M]
    ppt = new double[2]
    globalflag=false

    
    // Test RBF_interp
    myran = new Ran(17)
    pt = new double[M][2]
    for (i=0;i<M;i++) {
      pt[i][0]=(double)(N)*myran.doub()
      pt[i][1]=(double)(N)*myran.doub()
      actual[i]=cos(pt[i][0]/20.0)*cos(pt[i][1]/20.0)
    }
    for (i=0;i<N;i++) {
      for (j=0;j<N;j++) {
        k=N*i+j
        pts[k][0]=(double)(j)
        pts[k][1]=(double)(i)
        y[k]=cos(pts[k][0]/20.0)*cos(pts[k][1]/20.0)
      }
    }

    println("Testing RBF_interp with multiquadric function")
    scale=3.0
    multiquadric = new RBF_multiquadric(scale)
    myRBFmqf = new RBF_interp(pts,y,multiquadric,false)
    
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFmqf.interp(ppt)
    }
    
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,multiquadric: Inaccurate multquadric interpolation with no normalization.")
    }

    println("Testing RBF_interp with thinplate function")
    scale=2.0
    thinplate = new RBF_thinplate(scale)
    myRBFtpf = new RBF_interp(pts,y,thinplate,false)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFtpf.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)));
    localflag = maxel(vecsub(actual,estim)) > sbeps;
    globalflag = globalflag || localflag;
    if (localflag) {
      println("*** RBF_interp,thinplate: Inaccurate thinplate interpolation with no normalization.");
    }

    println("Testing RBF_interp with gauss function")
    scale=5.0
    gauss = new RBF_gauss(scale)
    myRBFgf = new RBF_interp (pts,y,gauss,false)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0];
      ppt[1]=pt[i][1];
      estim[i]=myRBFgf.interp(ppt);
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,gauss: Inaccurate gauss interpolation with no normalization.")
      
    }

    println("Testing RBF_interp with inversemultiquadric function")
    scale=3.0
    inversemultiquadric = new RBF_inversemultiquadric(scale)
    myRBFimqf =new RBF_interp(pts,y,inversemultiquadric, false)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFimqf.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,inversemultiquadric: Inaccurate inversemultiquadric interpolation with no normalization.")
    }

    // Test same interpolators with normalization turned on
    scale=3.0
    println("Testing RBF_interp with multiquadric function")
    myRBFmqt = new RBF_interp(pts,y,multiquadric,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFmqt.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,multiquadric: Inaccurate multiquadric interpolation with normalization.");
     }

    println("Testing RBF_interp with thinplate function")
    scale=2.0
    myRBFtpt =new RBF_interp(pts,y,thinplate,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0];
      ppt[1]=pt[i][1];
      estim[i]=myRBFtpt.interp(ppt);
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,thinplate: Inaccurate thinplate interpolation with normalization.");
    }

    println("Testing RBF_interp with gauss function")
    scale=5.0
    myRBFgt = new RBF_interp(pts,y,gauss,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFgt.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,gauss: Inaccurate gauss interpolation with normalization.");
    }

    println("Testing RBF_interp with inverse multiquadric function")
    scale=2.0
    myRBFimqt = new RBF_interp(pts,y,inversemultiquadric,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFimqt.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,inversemultiquadric: Inaccurate inversemultiquadric interpolation with normalization.")
    }

    if (globalflag)  println("Failed\n")
    else  println("Passed\n")

    

import static com.nr.test.NRTestUtil.maxel
import static com.nr.test.NRTestUtil.vecsub
import static java.lang.Math.cos

import com.nr.interp.RBF_gauss
import com.nr.interp.RBF_interp
import com.nr.interp.RBF_inversemultiquadric
import com.nr.interp.RBF_multiquadric
import com.nr.interp.RBF_thinplate
import com.nr.ran.Ran


    NPTS=100; NDIM=2; N=10; M=10;
    sbeps=0.05
    pts =new double[NPTS][NDIM]
    y = new double[NPTS]
    
    actual = new double[M]
    
    estim = new double[M]
    ppt = new double[2]
    globalflag=false

    
    // Test RBF_interp
    myran = new Ran(17)
    pt = new double[M][2]
    for (i=0;i<M;i++) {
      pt[i][0]=(double)(N)*myran.doub()
      pt[i][1]=(double)(N)*myran.doub()
      actual[i]=cos(pt[i][0]/20.0)*cos(pt[i][1]/20.0)
    }
    for (i=0;i<N;i++) {
      for (j=0;j<N;j++) {
        k=N*i+j
        pts[k][0]=(double)(j)
        pts[k][1]=(double)(i)
        y[k]=cos(pts[k][0]/20.0)*cos(pts[k][1]/20.0)
      }
    }

    println("Testing RBF_interp with multiquadric function")
    scale=3.0
    multiquadric = new RBF_multiquadric(scale)
    myRBFmqf = new RBF_interp(pts,y,multiquadric,false)
    
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFmqf.interp(ppt)
    }
    
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,multiquadric: Inaccurate multquadric interpolation with no normalization.")
    }

    println("Testing RBF_interp with thinplate function")
    scale=2.0
    thinplate = new RBF_thinplate(scale)
    myRBFtpf = new RBF_interp(pts,y,thinplate,false)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFtpf.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)));
    localflag = maxel(vecsub(actual,estim)) > sbeps;
    globalflag = globalflag || localflag;
    if (localflag) {
      println("*** RBF_interp,thinplate: Inaccurate thinplate interpolation with no normalization.");
    }

    println("Testing RBF_interp with gauss function")
    scale=5.0
    gauss = new RBF_gauss(scale)
    myRBFgf = new RBF_interp (pts,y,gauss,false)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0];
      ppt[1]=pt[i][1];
      estim[i]=myRBFgf.interp(ppt);
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,gauss: Inaccurate gauss interpolation with no normalization.")
      
    }

    println("Testing RBF_interp with inversemultiquadric function")
    scale=3.0
    inversemultiquadric = new RBF_inversemultiquadric(scale)
    myRBFimqf =new RBF_interp(pts,y,inversemultiquadric, false)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFimqf.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,inversemultiquadric: Inaccurate inversemultiquadric interpolation with no normalization.")
    }

    // Test same interpolators with normalization turned on
    scale=3.0
    println("Testing RBF_interp with multiquadric function")
    myRBFmqt = new RBF_interp(pts,y,multiquadric,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFmqt.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,multiquadric: Inaccurate multiquadric interpolation with normalization.");
     }

    println("Testing RBF_interp with thinplate function")
    scale=2.0
    myRBFtpt =new RBF_interp(pts,y,thinplate,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0];
      ppt[1]=pt[i][1];
      estim[i]=myRBFtpt.interp(ppt);
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,thinplate: Inaccurate thinplate interpolation with normalization.");
    }

    println("Testing RBF_interp with gauss function")
    scale=5.0
    myRBFgt = new RBF_interp(pts,y,gauss,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFgt.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,gauss: Inaccurate gauss interpolation with normalization.");
    }

    println("Testing RBF_interp with inverse multiquadric function")
    scale=2.0
    myRBFimqt = new RBF_interp(pts,y,inversemultiquadric,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFimqt.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,inversemultiquadric: Inaccurate inversemultiquadric interpolation with normalization.")
    }

    if (globalflag)  println("Failed\n")
    else  println("Passed\n")

    

import static com.nr.test.NRTestUtil.maxel
import static com.nr.test.NRTestUtil.vecsub
import static java.lang.Math.cos

import com.nr.interp.RBF_gauss
import com.nr.interp.RBF_interp
import com.nr.interp.RBF_inversemultiquadric
import com.nr.interp.RBF_multiquadric
import com.nr.interp.RBF_thinplate
import com.nr.ran.Ran


    NPTS=100; NDIM=2; N=10; M=10;
    sbeps=0.05
    pts =new double[NPTS][NDIM]
    y = new double[NPTS]
    
    actual = new double[M]
    
    estim = new double[M]
    ppt = new double[2]
    globalflag=false

    
    // Test RBF_interp
    myran = new Ran(17)
    pt = new double[M][2]
    for (i=0;i<M;i++) {
      pt[i][0]=(double)(N)*myran.doub()
      pt[i][1]=(double)(N)*myran.doub()
      actual[i]=cos(pt[i][0]/20.0)*cos(pt[i][1]/20.0)
    }
    for (i=0;i<N;i++) {
      for (j=0;j<N;j++) {
        k=N*i+j
        pts[k][0]=(double)(j)
        pts[k][1]=(double)(i)
        y[k]=cos(pts[k][0]/20.0)*cos(pts[k][1]/20.0)
      }
    }

    println("Testing RBF_interp with multiquadric function")
    scale=3.0
    multiquadric = new RBF_multiquadric(scale)
    myRBFmqf = new RBF_interp(pts,y,multiquadric,false)
    
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFmqf.interp(ppt)
    }
    
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,multiquadric: Inaccurate multquadric interpolation with no normalization.")
    }

    println("Testing RBF_interp with thinplate function")
    scale=2.0
    thinplate = new RBF_thinplate(scale)
    myRBFtpf = new RBF_interp(pts,y,thinplate,false)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFtpf.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)));
    localflag = maxel(vecsub(actual,estim)) > sbeps;
    globalflag = globalflag || localflag;
    if (localflag) {
      println("*** RBF_interp,thinplate: Inaccurate thinplate interpolation with no normalization.");
    }

    println("Testing RBF_interp with gauss function")
    scale=5.0
    gauss = new RBF_gauss(scale)
    myRBFgf = new RBF_interp (pts,y,gauss,false)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0];
      ppt[1]=pt[i][1];
      estim[i]=myRBFgf.interp(ppt);
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,gauss: Inaccurate gauss interpolation with no normalization.")
      
    }

    println("Testing RBF_interp with inversemultiquadric function")
    scale=3.0
    inversemultiquadric = new RBF_inversemultiquadric(scale)
    myRBFimqf =new RBF_interp(pts,y,inversemultiquadric, false)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFimqf.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,inversemultiquadric: Inaccurate inversemultiquadric interpolation with no normalization.")
    }

    // Test same interpolators with normalization turned on
    scale=3.0
    println("Testing RBF_interp with multiquadric function")
    myRBFmqt = new RBF_interp(pts,y,multiquadric,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFmqt.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,multiquadric: Inaccurate multiquadric interpolation with normalization.");
     }

    println("Testing RBF_interp with thinplate function")
    scale=2.0
    myRBFtpt =new RBF_interp(pts,y,thinplate,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0];
      ppt[1]=pt[i][1];
      estim[i]=myRBFtpt.interp(ppt);
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,thinplate: Inaccurate thinplate interpolation with normalization.");
    }

    println("Testing RBF_interp with gauss function")
    scale=5.0
    myRBFgt = new RBF_interp(pts,y,gauss,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFgt.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,gauss: Inaccurate gauss interpolation with normalization.");
    }

    println("Testing RBF_interp with inverse multiquadric function")
    scale=2.0
    myRBFimqt = new RBF_interp(pts,y,inversemultiquadric,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFimqt.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,inversemultiquadric: Inaccurate inversemultiquadric interpolation with normalization.")
    }

    if (globalflag)  println("Failed\n")
    else  println("Passed\n")

    

import static com.nr.test.NRTestUtil.maxel
import static com.nr.test.NRTestUtil.vecsub
import static java.lang.Math.cos

import com.nr.interp.RBF_gauss
import com.nr.interp.RBF_interp
import com.nr.interp.RBF_inversemultiquadric
import com.nr.interp.RBF_multiquadric
import com.nr.interp.RBF_thinplate
import com.nr.ran.Ran


    NPTS=100; NDIM=2; N=10; M=10;
    sbeps=0.05
    pts =new double[NPTS][NDIM]
    y = new double[NPTS]
    
    actual = new double[M]
    
    estim = new double[M]
    ppt = new double[2]
    globalflag=false

    
    // Test RBF_interp
    myran = new Ran(17)
    pt = new double[M][2]
    for (i=0;i<M;i++) {
      pt[i][0]=(double)(N)*myran.doub()
      pt[i][1]=(double)(N)*myran.doub()
      actual[i]=cos(pt[i][0]/20.0)*cos(pt[i][1]/20.0)
    }
    for (i=0;i<N;i++) {
      for (j=0;j<N;j++) {
        k=N*i+j
        pts[k][0]=(double)(j)
        pts[k][1]=(double)(i)
        y[k]=cos(pts[k][0]/20.0)*cos(pts[k][1]/20.0)
      }
    }

    println("Testing RBF_interp with multiquadric function")
    scale=3.0
    multiquadric = new RBF_multiquadric(scale)
    myRBFmqf = new RBF_interp(pts,y,multiquadric,false)
    
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFmqf.interp(ppt)
    }
    
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,multiquadric: Inaccurate multquadric interpolation with no normalization.")
    }

    println("Testing RBF_interp with thinplate function")
    scale=2.0
    thinplate = new RBF_thinplate(scale)
    myRBFtpf = new RBF_interp(pts,y,thinplate,false)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFtpf.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)));
    localflag = maxel(vecsub(actual,estim)) > sbeps;
    globalflag = globalflag || localflag;
    if (localflag) {
      println("*** RBF_interp,thinplate: Inaccurate thinplate interpolation with no normalization.");
    }

    println("Testing RBF_interp with gauss function")
    scale=5.0
    gauss = new RBF_gauss(scale)
    myRBFgf = new RBF_interp (pts,y,gauss,false)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0];
      ppt[1]=pt[i][1];
      estim[i]=myRBFgf.interp(ppt);
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,gauss: Inaccurate gauss interpolation with no normalization.")
      
    }

    println("Testing RBF_interp with inversemultiquadric function")
    scale=3.0
    inversemultiquadric = new RBF_inversemultiquadric(scale)
    myRBFimqf =new RBF_interp(pts,y,inversemultiquadric, false)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFimqf.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,inversemultiquadric: Inaccurate inversemultiquadric interpolation with no normalization.")
    }

    // Test same interpolators with normalization turned on
    scale=3.0
    println("Testing RBF_interp with multiquadric function")
    myRBFmqt = new RBF_interp(pts,y,multiquadric,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFmqt.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,multiquadric: Inaccurate multiquadric interpolation with normalization.");
     }

    println("Testing RBF_interp with thinplate function")
    scale=2.0
    myRBFtpt =new RBF_interp(pts,y,thinplate,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0];
      ppt[1]=pt[i][1];
      estim[i]=myRBFtpt.interp(ppt);
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,thinplate: Inaccurate thinplate interpolation with normalization.");
    }

    println("Testing RBF_interp with gauss function")
    scale=5.0
    myRBFgt = new RBF_interp(pts,y,gauss,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFgt.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,gauss: Inaccurate gauss interpolation with normalization.");
    }

    println("Testing RBF_interp with inverse multiquadric function")
    scale=2.0
    myRBFimqt = new RBF_interp(pts,y,inversemultiquadric,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFimqt.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,inversemultiquadric: Inaccurate inversemultiquadric interpolation with normalization.")
    }

    if (globalflag)  println("Failed\n")
    else  println("Passed\n")

    

import static com.nr.test.NRTestUtil.maxel
import static com.nr.test.NRTestUtil.vecsub
import static java.lang.Math.cos

import com.nr.interp.RBF_gauss
import com.nr.interp.RBF_interp
import com.nr.interp.RBF_inversemultiquadric
import com.nr.interp.RBF_multiquadric
import com.nr.interp.RBF_thinplate
import com.nr.ran.Ran


    NPTS=100; NDIM=2; N=10; M=10;
    sbeps=0.05
    pts =new double[NPTS][NDIM]
    y = new double[NPTS]
    
    actual = new double[M]
    
    estim = new double[M]
    ppt = new double[2]
    globalflag=false

    
    // Test RBF_interp
    myran = new Ran(17)
    pt = new double[M][2]
    for (i=0;i<M;i++) {
      pt[i][0]=(double)(N)*myran.doub()
      pt[i][1]=(double)(N)*myran.doub()
      actual[i]=cos(pt[i][0]/20.0)*cos(pt[i][1]/20.0)
    }
    for (i=0;i<N;i++) {
      for (j=0;j<N;j++) {
        k=N*i+j
        pts[k][0]=(double)(j)
        pts[k][1]=(double)(i)
        y[k]=cos(pts[k][0]/20.0)*cos(pts[k][1]/20.0)
      }
    }

    println("Testing RBF_interp with multiquadric function")
    scale=3.0
    multiquadric = new RBF_multiquadric(scale)
    myRBFmqf = new RBF_interp(pts,y,multiquadric,false)
    
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFmqf.interp(ppt)
    }
    
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,multiquadric: Inaccurate multquadric interpolation with no normalization.")
    }

    println("Testing RBF_interp with thinplate function")
    scale=2.0
    thinplate = new RBF_thinplate(scale)
    myRBFtpf = new RBF_interp(pts,y,thinplate,false)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFtpf.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)));
    localflag = maxel(vecsub(actual,estim)) > sbeps;
    globalflag = globalflag || localflag;
    if (localflag) {
      println("*** RBF_interp,thinplate: Inaccurate thinplate interpolation with no normalization.");
    }

    println("Testing RBF_interp with gauss function")
    scale=5.0
    gauss = new RBF_gauss(scale)
    myRBFgf = new RBF_interp (pts,y,gauss,false)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0];
      ppt[1]=pt[i][1];
      estim[i]=myRBFgf.interp(ppt);
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,gauss: Inaccurate gauss interpolation with no normalization.")
      
    }

    println("Testing RBF_interp with inversemultiquadric function")
    scale=3.0
    inversemultiquadric = new RBF_inversemultiquadric(scale)
    myRBFimqf =new RBF_interp(pts,y,inversemultiquadric, false)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFimqf.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,inversemultiquadric: Inaccurate inversemultiquadric interpolation with no normalization.")
    }

    // Test same interpolators with normalization turned on
    scale=3.0
    println("Testing RBF_interp with multiquadric function")
    myRBFmqt = new RBF_interp(pts,y,multiquadric,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFmqt.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,multiquadric: Inaccurate multiquadric interpolation with normalization.");
     }

    println("Testing RBF_interp with thinplate function")
    scale=2.0
    myRBFtpt =new RBF_interp(pts,y,thinplate,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0];
      ppt[1]=pt[i][1];
      estim[i]=myRBFtpt.interp(ppt);
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,thinplate: Inaccurate thinplate interpolation with normalization.");
    }

    println("Testing RBF_interp with gauss function")
    scale=5.0
    myRBFgt = new RBF_interp(pts,y,gauss,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFgt.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,gauss: Inaccurate gauss interpolation with normalization.");
    }

    println("Testing RBF_interp with inverse multiquadric function")
    scale=2.0
    myRBFimqt = new RBF_interp(pts,y,inversemultiquadric,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFimqt.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,inversemultiquadric: Inaccurate inversemultiquadric interpolation with normalization.")
    }

    if (globalflag)  println("Failed\n")
    else  println("Passed\n")

    

import static com.nr.test.NRTestUtil.maxel
import static com.nr.test.NRTestUtil.vecsub
import static java.lang.Math.cos

import com.nr.interp.RBF_gauss
import com.nr.interp.RBF_interp
import com.nr.interp.RBF_inversemultiquadric
import com.nr.interp.RBF_multiquadric
import com.nr.interp.RBF_thinplate
import com.nr.ran.Ran


    NPTS=100; NDIM=2; N=10; M=10;
    sbeps=0.05
    pts =new double[NPTS][NDIM]
    y = new double[NPTS]
    
    actual = new double[M]
    
    estim = new double[M]
    ppt = new double[2]
    globalflag=false

    
    // Test RBF_interp
    myran = new Ran(17)
    pt = new double[M][2]
    for (i=0;i<M;i++) {
      pt[i][0]=(double)(N)*myran.doub()
      pt[i][1]=(double)(N)*myran.doub()
      actual[i]=cos(pt[i][0]/20.0)*cos(pt[i][1]/20.0)
    }
    for (i=0;i<N;i++) {
      for (j=0;j<N;j++) {
        k=N*i+j
        pts[k][0]=(double)(j)
        pts[k][1]=(double)(i)
        y[k]=cos(pts[k][0]/20.0)*cos(pts[k][1]/20.0)
      }
    }

    println("Testing RBF_interp with multiquadric function")
    scale=3.0
    multiquadric = new RBF_multiquadric(scale)
    myRBFmqf = new RBF_interp(pts,y,multiquadric,false)
    
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFmqf.interp(ppt)
    }
    
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,multiquadric: Inaccurate multquadric interpolation with no normalization.")
    }

    println("Testing RBF_interp with thinplate function")
    scale=2.0
    thinplate = new RBF_thinplate(scale)
    myRBFtpf = new RBF_interp(pts,y,thinplate,false)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFtpf.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)));
    localflag = maxel(vecsub(actual,estim)) > sbeps;
    globalflag = globalflag || localflag;
    if (localflag) {
      println("*** RBF_interp,thinplate: Inaccurate thinplate interpolation with no normalization.");
    }

    println("Testing RBF_interp with gauss function")
    scale=5.0
    gauss = new RBF_gauss(scale)
    myRBFgf = new RBF_interp (pts,y,gauss,false)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0];
      ppt[1]=pt[i][1];
      estim[i]=myRBFgf.interp(ppt);
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,gauss: Inaccurate gauss interpolation with no normalization.")
      
    }

    println("Testing RBF_interp with inversemultiquadric function")
    scale=3.0
    inversemultiquadric = new RBF_inversemultiquadric(scale)
    myRBFimqf =new RBF_interp(pts,y,inversemultiquadric, false)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFimqf.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,inversemultiquadric: Inaccurate inversemultiquadric interpolation with no normalization.")
    }

    // Test same interpolators with normalization turned on
    scale=3.0
    println("Testing RBF_interp with multiquadric function")
    myRBFmqt = new RBF_interp(pts,y,multiquadric,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFmqt.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,multiquadric: Inaccurate multiquadric interpolation with normalization.");
     }

    println("Testing RBF_interp with thinplate function")
    scale=2.0
    myRBFtpt =new RBF_interp(pts,y,thinplate,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0];
      ppt[1]=pt[i][1];
      estim[i]=myRBFtpt.interp(ppt);
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,thinplate: Inaccurate thinplate interpolation with normalization.");
    }

    println("Testing RBF_interp with gauss function")
    scale=5.0
    myRBFgt = new RBF_interp(pts,y,gauss,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFgt.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,gauss: Inaccurate gauss interpolation with normalization.");
    }

    println("Testing RBF_interp with inverse multiquadric function")
    scale=2.0
    myRBFimqt = new RBF_interp(pts,y,inversemultiquadric,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFimqt.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,inversemultiquadric: Inaccurate inversemultiquadric interpolation with normalization.")
    }

    if (globalflag)  println("Failed\n")
    else  println("Passed\n")

    

import static com.nr.test.NRTestUtil.maxel
import static com.nr.test.NRTestUtil.vecsub
import static java.lang.Math.cos

import com.nr.interp.RBF_gauss
import com.nr.interp.RBF_interp
import com.nr.interp.RBF_inversemultiquadric
import com.nr.interp.RBF_multiquadric
import com.nr.interp.RBF_thinplate
import com.nr.ran.Ran


    NPTS=100; NDIM=2; N=10; M=10;
    sbeps=0.05
    pts =new double[NPTS][NDIM]
    y = new double[NPTS]
    
    actual = new double[M]
    
    estim = new double[M]
    ppt = new double[2]
    globalflag=false

    
    // Test RBF_interp
    myran = new Ran(17)
    pt = new double[M][2]
    for (i=0;i<M;i++) {
      pt[i][0]=(double)(N)*myran.doub()
      pt[i][1]=(double)(N)*myran.doub()
      actual[i]=cos(pt[i][0]/20.0)*cos(pt[i][1]/20.0)
    }
    for (i=0;i<N;i++) {
      for (j=0;j<N;j++) {
        k=N*i+j
        pts[k][0]=(double)(j)
        pts[k][1]=(double)(i)
        y[k]=cos(pts[k][0]/20.0)*cos(pts[k][1]/20.0)
      }
    }

    println("Testing RBF_interp with multiquadric function")
    scale=3.0
    multiquadric = new RBF_multiquadric(scale)
    myRBFmqf = new RBF_interp(pts,y,multiquadric,false)
    
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFmqf.interp(ppt)
    }
    
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,multiquadric: Inaccurate multquadric interpolation with no normalization.")
    }

    println("Testing RBF_interp with thinplate function")
    scale=2.0
    thinplate = new RBF_thinplate(scale)
    myRBFtpf = new RBF_interp(pts,y,thinplate,false)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFtpf.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)));
    localflag = maxel(vecsub(actual,estim)) > sbeps;
    globalflag = globalflag || localflag;
    if (localflag) {
      println("*** RBF_interp,thinplate: Inaccurate thinplate interpolation with no normalization.");
    }

    println("Testing RBF_interp with gauss function")
    scale=5.0
    gauss = new RBF_gauss(scale)
    myRBFgf = new RBF_interp (pts,y,gauss,false)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0];
      ppt[1]=pt[i][1];
      estim[i]=myRBFgf.interp(ppt);
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,gauss: Inaccurate gauss interpolation with no normalization.")
      
    }

    println("Testing RBF_interp with inversemultiquadric function")
    scale=3.0
    inversemultiquadric = new RBF_inversemultiquadric(scale)
    myRBFimqf =new RBF_interp(pts,y,inversemultiquadric, false)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFimqf.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,inversemultiquadric: Inaccurate inversemultiquadric interpolation with no normalization.")
    }

    // Test same interpolators with normalization turned on
    scale=3.0
    println("Testing RBF_interp with multiquadric function")
    myRBFmqt = new RBF_interp(pts,y,multiquadric,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFmqt.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,multiquadric: Inaccurate multiquadric interpolation with normalization.");
     }

    println("Testing RBF_interp with thinplate function")
    scale=2.0
    myRBFtpt =new RBF_interp(pts,y,thinplate,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0];
      ppt[1]=pt[i][1];
      estim[i]=myRBFtpt.interp(ppt);
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,thinplate: Inaccurate thinplate interpolation with normalization.");
    }

    println("Testing RBF_interp with gauss function")
    scale=5.0
    myRBFgt = new RBF_interp(pts,y,gauss,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFgt.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,gauss: Inaccurate gauss interpolation with normalization.");
    }

    println("Testing RBF_interp with inverse multiquadric function")
    scale=2.0
    myRBFimqt = new RBF_interp(pts,y,inversemultiquadric,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFimqt.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,inversemultiquadric: Inaccurate inversemultiquadric interpolation with normalization.")
    }

    if (globalflag)  println("Failed\n")
    else  println("Passed\n")

    

import static com.nr.test.NRTestUtil.maxel
import static com.nr.test.NRTestUtil.vecsub
import static java.lang.Math.cos

import com.nr.interp.RBF_gauss
import com.nr.interp.RBF_interp
import com.nr.interp.RBF_inversemultiquadric
import com.nr.interp.RBF_multiquadric
import com.nr.interp.RBF_thinplate
import com.nr.ran.Ran


    NPTS=100; NDIM=2; N=10; M=10;
    sbeps=0.05
    pts =new double[NPTS][NDIM]
    y = new double[NPTS]
    
    actual = new double[M]
    
    estim = new double[M]
    ppt = new double[2]
    globalflag=false

    
    // Test RBF_interp
    myran = new Ran(17)
    pt = new double[M][2]
    for (i=0;i<M;i++) {
      pt[i][0]=(double)(N)*myran.doub()
      pt[i][1]=(double)(N)*myran.doub()
      actual[i]=cos(pt[i][0]/20.0)*cos(pt[i][1]/20.0)
    }
    for (i=0;i<N;i++) {
      for (j=0;j<N;j++) {
        k=N*i+j
        pts[k][0]=(double)(j)
        pts[k][1]=(double)(i)
        y[k]=cos(pts[k][0]/20.0)*cos(pts[k][1]/20.0)
      }
    }

    println("Testing RBF_interp with multiquadric function")
    scale=3.0
    multiquadric = new RBF_multiquadric(scale)
    myRBFmqf = new RBF_interp(pts,y,multiquadric,false)
    
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFmqf.interp(ppt)
    }
    
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,multiquadric: Inaccurate multquadric interpolation with no normalization.")
    }

    println("Testing RBF_interp with thinplate function")
    scale=2.0
    thinplate = new RBF_thinplate(scale)
    myRBFtpf = new RBF_interp(pts,y,thinplate,false)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFtpf.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)));
    localflag = maxel(vecsub(actual,estim)) > sbeps;
    globalflag = globalflag || localflag;
    if (localflag) {
      println("*** RBF_interp,thinplate: Inaccurate thinplate interpolation with no normalization.");
    }

    println("Testing RBF_interp with gauss function")
    scale=5.0
    gauss = new RBF_gauss(scale)
    myRBFgf = new RBF_interp (pts,y,gauss,false)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0];
      ppt[1]=pt[i][1];
      estim[i]=myRBFgf.interp(ppt);
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,gauss: Inaccurate gauss interpolation with no normalization.")
      
    }

    println("Testing RBF_interp with inversemultiquadric function")
    scale=3.0
    inversemultiquadric = new RBF_inversemultiquadric(scale)
    myRBFimqf =new RBF_interp(pts,y,inversemultiquadric, false)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFimqf.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,inversemultiquadric: Inaccurate inversemultiquadric interpolation with no normalization.")
    }

    // Test same interpolators with normalization turned on
    scale=3.0
    println("Testing RBF_interp with multiquadric function")
    myRBFmqt = new RBF_interp(pts,y,multiquadric,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFmqt.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,multiquadric: Inaccurate multiquadric interpolation with normalization.");
     }

    println("Testing RBF_interp with thinplate function")
    scale=2.0
    myRBFtpt =new RBF_interp(pts,y,thinplate,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0];
      ppt[1]=pt[i][1];
      estim[i]=myRBFtpt.interp(ppt);
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,thinplate: Inaccurate thinplate interpolation with normalization.");
    }

    println("Testing RBF_interp with gauss function")
    scale=5.0
    myRBFgt = new RBF_interp(pts,y,gauss,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFgt.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,gauss: Inaccurate gauss interpolation with normalization.");
    }

    println("Testing RBF_interp with inverse multiquadric function")
    scale=2.0
    myRBFimqt = new RBF_interp(pts,y,inversemultiquadric,true)
    for (i=0;i<M;i++) {
      ppt[0]=pt[i][0]
      ppt[1]=pt[i][1]
      estim[i]=myRBFimqt.interp(ppt)
    }
    printf("     Discrepancy: %f\n", maxel(vecsub(actual,estim)))
    localflag = maxel(vecsub(actual,estim)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      println("*** RBF_interp,inversemultiquadric: Inaccurate inversemultiquadric interpolation with normalization.")
    }

    if (globalflag)  println("Failed\n")
    else  println("Passed\n")

    
}}}

== Cholesky Decomposition ==

{{{




import static com.nr.NRUtil.*
import static com.nr.test.NRTestUtil.*

import com.nr.la.Cholesky

 diag=10.0
 a = new double[50][50]
    
 r=new double[50]
  
 y=new double[50]
 globalflag=false
    
 ranmat(a, diag)
 ranvec(r)   

println("Testing cholesky")

// make a positive definite matrix
aposdef = matmul(a, transpose(a).getArray())    

// perform a Cholesky factorization of the matrix, p. 101 NR3
ach = new Cholesky(aposdef)

// solve using Cholesky factorization, p. 101 NR3
ach.solve(r,y)

sbeps = 5.0e-15
localflag = maxel(vecsub(matmul(aposdef,y),r)) > sbeps
    globalflag = globalflag || localflag
    if (localflag) {
      fail("*** cholesky: Error in solve() method");
      
    }

residual = aposdef*y-r   // should be zero

    

}}}