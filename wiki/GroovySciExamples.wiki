#summary We provide some examples of working with GroovySci in jLab.

= Introduction =

`In this page we provide small examples of using GroovySci, the default jLab mode, in scientific applications. The code can be executed either:`

  *  `by pasting it at the jLab's command console (it must be in GroovySci mode, not in jScript, F2 switches these modes)`
  *  `by pasting the code within the jLab's programmer's editor, select the code and pressing F6`
 


== Henon Chaotic Map ==

`This small GroovySci script computes some iterations of the Henon chaotic map and plots them. `

{{{
x = 0d; y = 0d;
niters = 10000; 

alpha = 1.4d;
beta = 0.3d;
tic();
xy=new double[2][niters];
for (k=1; k<niters; k++)  {
  xp = x;yp=y;
  x = 1+yp-alpha *xp*xp;
  y = beta*xp;
  xy[0][k] = x;
  xy[1][k] = y;
};

scatterPlotsOn()    // plot points without connecting with lines
plot(xy);

}}}


== Baker map ==

{{{




x = (double)0.1; y = (double)0.22;
niters = getInt("How many iterations of the Ikeda map");
xall = new double[niters]
yall = new double[niters]

y13 = (double)1.0/(double)3.0
y23 = (double)2.0/(double)3.0
tic() 
for (k in 1..niters-1)  {
  xp = x; yp=y
 if (y<=0.5) {
   y = 2*yp
   x = y13*xp
}
else {
  x = y13*xp+y23
  y = 2*yp - 1
  }

  xall[k] = x
  yall[k] = y
}

tm = toc()
scatterPlotsOn()
figure(1)
plot(xall, yall, "time = "+tm)

}}}

== Ikeda Chaotic Map ==

{{{

// the Ikeda map
 R = 1;  C1 = 0.4; C2 = 0.9;  C3 = 6


niters = getInt("How many iterations of the Ikeda map");
x = new double[niters]
y = new double[niters]
x[0]=0.12; y[0]=0.2

tic() 
k=1
km=0
 tau=0.0;  sintau=0.0;  costau=0.0

while  (k< niters)  {
  km=k-1
  tau = C1-C3/(1+x[km]*x[km]+y[km]*y[km])
  sintau = sin(tau); costau = cos(tau);
  x[k] = R+C2*(x[km]*costau-y[km]*sintau)
  y[k] = C2*(x[km]*sintau+y[km]*costau)
 
  k++
}

tm = toc()
scatterPlotsOn()
figure(1)
plot(x, y, "time = "+tm)

}}}


== Demonstrating surface plots ==
{{{

// demonstrate a surface plot
 // below is the script code. It is wrapped to a class of name surfPlot by Groovy
 X = inc(-2, 0.2, 2);
 Y = inc(-2, 0.2, 2);
  
 x = X.getArray()[0];
 y = Y.getArray()[0];
 
 
z1 = Functions.f1(x, y);
z2 = Functions.f2(x, y);

figure3d(1);  surf(x, y, z1, "Surface Plot");
figure3d(2);  surf(x, y, z2, "Surface Plot 2");
figure3d(3);  surf(x, y, z1, "Surface Plot"); surf(x, y, z2, "Surface Plot 2");

class Functions {
	// function definition: z=cos(PI*x)*sin(PI*y)
	public static double f1(double x, double y) {
		double z = Math.cos(x * Math.PI) * Math.sin(y *Math.PI);
		return z;
	}
 
	// grid version of the function
	public static double[][] f1(double[] x, double[] y) {
		double[][] z = new double[y.length][x.length];
		for (int i = 0; i < x.length; i++)
			for (int j = 0; j < y.length; j++)
				z[j][i] = f1(x[i], y[j]);
		return z;
	}
 
	// another function definition: z=sin(PI*x)*cos(PI*y)
	public static double f2(double x, double y) {
		double z = Math.sin(x * Math.PI) * Math.cos(y * Math.PI);
		return z;
	}
 
	// grid version of the function
	public static double[][] f2(double[] x, double[] y) {
		double[][] z = new double[y.length][x.length];
		for (int i = 0; i < x.length; i++)
			for (int j = 0; j < y.length; j++)
				z[j][i] = f2(x[i], y[j]);
		return z;
	}
  }

 
}}}